%import {
#include "winsup.h"
#include "devices.h"
#include "sys/cygwin.h"
#include "tty.h"
#include "pinfo.h"
#include "shared_info.h"
#include "ntdll.h"
typedef const device *KR_device_t;
}
%type KR_device_t
%local {
const device dev_cygdrive_storage =
  {"/cygdrive", {FH_CYGDRIVE}, "/cygdrive"};

const device dev_fs_storage =
  {"", {FH_FS}, ""};

const device dev_proc_storage =
  {"", {FH_PROC}, ""};

const device dev_procnet_storage =
  {"", {FH_PROCNET}, ""};

const device dev_procsys_storage =
  {"", {FH_PROCSYS}, ""};

const device dev_procsysvipc_storage =
  {"", {FH_PROCSYSVIPC}, ""};

const device dev_netdrive_storage =
  {"", {FH_NETDRIVE}, ""};

const device dev_dev_storage =
  {"/dev", {FH_DEV}, "/dev"};

const device dev_registry_storage =
  {"", {FH_REGISTRY}, ""};

const device dev_piper_storage =
  {"", {FH_PIPER}, ""};

const device dev_pipew_storage =
  {"", {FH_PIPEW}, ""};

const device dev_tcp_storage =
  {"", {FH_TCP}, ""};

const device dev_udp_storage =
  {"", {FH_UDP}, ""};

const device dev_stream_storage =
  {"", {FH_STREAM}, ""};

const device dev_dgram_storage =
  {"", {FH_DGRAM}, ""};

const device dev_bad_storage =
  {"", {FH_NADA}, ""};

const device dev_error_storage =
  {"", {FH_ERROR}, ""};
#define BRACK(x) {devn_int: x}

%storage_here
}
%%
"/dev/tty", BRACK(FH_TTY), "/dev/tty"
"/dev/pty%(0-63)d", BRACK(FHDEV(DEV_PTYS_MAJOR, {$1})), "/dev/pty{$1}", &device::exists_ptys, ptys_dev
"/dev/ptym%(0-63)d", BRACK(FHDEV(DEV_PTYM_MAJOR, {$1})), "/dev/ptym{$1}", &device::exists_never, ptym_dev
"/dev/cons%(0-63)d", BRACK(FHDEV(DEV_CONS_MAJOR, {$1})), "/dev/cons{$1}", &device::exists_cons, cons_dev
"/dev/console", BRACK(FH_CONSOLE), "/dev/console", &device::exists_console, console_dev
"/dev/ptmx", BRACK(FH_PTMX), "/dev/ptmx"
"/dev/windows", BRACK(FH_WINDOWS), "/dev/windows"
"/dev/dsp", BRACK(FH_OSS_DSP), "/dev/dsp"
"/dev/conin", BRACK(FH_CONIN), "/dev/conin", &device::exists_console
"/dev/conout", BRACK(FH_CONOUT), "/dev/conout", &device::exists_console
"/dev/null", BRACK(FH_NULL), "\\Device\\Null"
"/dev/zero", BRACK(FH_ZERO), "/dev/zero"
"/dev/full", BRACK(FH_FULL), "/dev/full"
"/dev/random", BRACK(FH_RANDOM), "/dev/random"
"/dev/urandom", BRACK(FH_URANDOM), "/dev/urandom", urandom_dev
"/dev/mem", BRACK(FH_MEM), "/dev/mem"
"/dev/kmem", BRACK(FH_KMEM), "/dev/mem"
"/dev/clipboard", BRACK(FH_CLIPBOARD), "/dev/clipboard"
"/dev/port", BRACK(FH_PORT), "/dev/port"
"/dev/com%(1-16)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1 - 1})), "\\??\\COM{$1}", &device::exists_never
"/dev/ttyS%(0-63)d", BRACK(FHDEV(DEV_SERIAL_MAJOR, {$1})), "\\??\\COM{$1 + 1}", &device::exists_nt_dev
"/dev/pipe", BRACK(FH_PIPE), "/dev/pipe", &device::exists_never
"/dev/fifo", BRACK(FH_FIFO), "/dev/fifo", &device::exists_never
"/dev/st%(0-127)d", BRACK(FHDEV(DEV_TAPE_MAJOR, {$1})), "\\Device\\Tape{$1}", &device::exists_nt_dev
"/dev/nst%(0-127)d", BRACK(FHDEV(DEV_TAPE_MAJOR, {$1 + 128})), "\\Device\\Tape{$1}", &device::exists_nt_dev
"/dev/fd%(0-15)d", BRACK(FHDEV(DEV_FLOPPY_MAJOR, {$1})), "\\Device\\Floppy{$1}", &device::exists_nt_dev
"/dev/scd%(0-15)d", BRACK(FHDEV(DEV_CDROM_MAJOR, {$1})), "\\Device\\CdRom{$1}", &device::exists_nt_dev
"/dev/sr%(0-15)d", BRACK(FHDEV(DEV_CDROM_MAJOR, {$1})), "\\Device\\CdRom{$1}", &device::exists_nt_dev
"/dev/sd%{a-z}s", BRACK(FH_SD{uc $1}), "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sda%{a-z}s", BRACK(FH_SDA{uc $1}), "\\Device\\Harddisk{26 + ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sdb%{a-z}s", BRACK(FH_SDB{uc $1}), "\\Device\\Harddisk{52 + ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sdc%{a-z}s", BRACK(FH_SDC{uc $1}), "\\Device\\Harddisk{78 + ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sdd%{a-x}s", BRACK(FH_SDD{uc $1}), "\\Device\\Harddisk{104 + ord($1) - ord('a')}\\Partition0", &device::exists_nt_dev
"/dev/sd%{a-z}s%(1-15)d", BRACK(FH_SD{uc $1} | {$2}), "\\Device\\Harddisk{ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/sda%{a-z}s%(1-15)d", BRACK(FH_SDA{uc $1} | {$2}), "\\Device\\Harddisk{26 + ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/sdb%{a-z}s%(1-15)d", BRACK(FH_SDB{uc $1} | {$2}), "\\Device\\Harddisk{52 + ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/sdc%{a-z}s%(1-15)d", BRACK(FH_SDC{uc $1} | {$2}), "\\Device\\Harddisk{78 + ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/sdd%{a-x}s%(1-15)d", BRACK(FH_SDD{uc $1} | {$2}), "\\Device\\Harddisk{104 + ord($1) - ord('a')}\\Partition{$2 % 16}", &device::exists_nt_dev
"/dev/kmsg", BRACK(FH_KMSG), "\\Device\\MailSlot\\cygwin\\dev\\kmsg"
"/dev", BRACK(FH_DEV), "/dev"
%other	{return	NULL;}
%%
#undef BRACK

const device *dev_storage_end = dev_storage + (sizeof dev_storage / sizeof dev_storage[0]);

void
device::parse (const char *s)
{
  size_t len = strlen (s);
  const device *dev = KR_find_keyword (s, len);

  if (!dev)
    *this = *fs_dev;
  else
    *this = *dev;
}

void
device::init ()
{
  /* nothing to do... yet */
}

void
device::parse (_major_t major, _minor_t minor)
{
  _dev_t dev = FHDEV (major, minor);

  d.devn = 0;

  for (unsigned i = 0; i < (sizeof (dev_storage) / sizeof (dev_storage[0])); i++)
    if (dev_storage[i].d.devn == dev)
      {
	*this = dev_storage[i];
	break;
      }

  if (!*this)
    d.devn = FHDEV (major, minor);
}

void
device::parse (_dev_t dev)
{
  parse (_major (dev), _minor (dev));
}

void
device::parsedisk (int drive, int part)
{
  int base;
  if (drive < ('q' - 'a'))      /* /dev/sda -to- /dev/sdp */
    base = DEV_SD_MAJOR;
  else if (drive < 32)		/* /dev/sdq -to- /dev/sdaf */
    {
      base = DEV_SD1_MAJOR;
      drive -= 'q' - 'a';
    }
  else if (drive < 48)		/* /dev/sdag -to- /dev/sdav */
    {
      base = DEV_SD2_MAJOR;
      drive -= 32;
    }
  else if (drive < 64)		/* /dev/sdaw -to- /dev/sdbl */
    {
      base = DEV_SD3_MAJOR;
      drive -= 48;
    }
  else if (drive < 80)		/* /dev/sdbm -to- /dev/sdcb */
    {
      base = DEV_SD4_MAJOR;
      drive -= 64;
    }
  else if (drive < 96)		/* /dev/sdcc -to- /dev/sdcr */
    {
      base = DEV_SD5_MAJOR;
      drive -= 80;
    }
  else if (drive < 112)		/* /dev/sdcs -to- /dev/sddh */
    {
      base = DEV_SD6_MAJOR;
      drive -= 96;
    }
  /* NOTE: This will cause multiple /dev/sddx entries in
	   /proc/partitions if there are more than 128 devices */
  else				/* /dev/sddi -to- /dev/sddx */
    {
      base = DEV_SD7_MAJOR;
      drive -= 112;
    }
  parse (base, part + (drive * 16));
}

bool
device::exists_never () const
{
  return false;
}

bool
device::exists_ptys () const
{
  /* Only in-use ptys exist. */
  return cygwin_shared->tty.connect (get_minor ()) != -1;
}

bool
device::exists_cons () const
{
  /* /dev/consX only exists, if it's the current controlling tty. */
  return iscons_dev (myself->ctty) && myself->ctty == d.devn_int;
}

bool
device::exists_console () const
{
  /* console, conin, conout only exist if a console is our controlling tty. */
  return iscons_dev (myself->ctty);
}

bool
device::exists_nt_dev () const
{
  /* POSIX devices backed by real NT devices only exist if their NT device
     exists. */
  WCHAR wpath[MAX_PATH];
  UNICODE_STRING upath;
  OBJECT_ATTRIBUTES attr;
  HANDLE h;
  NTSTATUS status;

  sys_mbstowcs (wpath, MAX_PATH, native);
  RtlInitUnicodeString (&upath, wpath);
  InitializeObjectAttributes (&attr, &upath,
			      OBJ_CASE_INSENSITIVE, NULL, NULL);
  /* Except for the serial IO devices, the native paths are direct device
     paths, not symlinks, so every status code except for "NOT_FOUND" means
     the device exists. */
  status = NtOpenSymbolicLinkObject (&h, SYMBOLIC_LINK_QUERY, &attr);
  switch (status)
    {
    case STATUS_OBJECT_NAME_NOT_FOUND:
    case STATUS_OBJECT_PATH_NOT_FOUND:
      return false;
    case STATUS_SUCCESS:
      NtClose (h);
      break;
    default:
      break;
    }
  return true;
}

bool  
device::exists () const
{
  if (!exists_func)
    return true;
  return (this->*exists_func)();
}
