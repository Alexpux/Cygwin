/* fcntl.cc: fcntl syscall

   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2008, 2009,
   2010, 2011, 2012 Red Hat, Inc.

This file is part of Cygwin.

This software is a copyrighted work licensed under the terms of the
Cygwin license.  Please consult the file "CYGWIN_LICENSE" for
details. */

#include "winsup.h"
#include <unistd.h>
#include "cygerrno.h"
#include "security.h"
#include "path.h"
#include "fhandler.h"
#include "dtable.h"
#include "cygheap.h"
#include "cygtls.h"

extern "C" int
fcntl64 (int fd, int cmd, ...)
{
  int res = -1;
  intptr_t arg = 0;
  va_list args;

  pthread_testcancel ();

  debug_printf ("fcntl(%d, %d, ...)", fd, cmd);
  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  cygheap_fdget cfd (fd, true);
  if (cfd < 0)
    goto done;

  /* FIXME?  All numerical args to fcntl are defined as long on Linux.
     This relies on a really dirty trick on x86_64:  A 32 bit mov to
     a register (e.g. mov $1, %edx) always sets the high 32 bit to 0.
     We're following the Linux lead here since the third arg to any
     function is in a register anyway (%r8 in MS ABI).  That's the easy
     case which is covered here by always reading the arg with
     sizeof (intptr_t) == sizeof (long) == sizeof (void*) which matches
     all targets.
     
     However, the POSIX standard defines all numerical args as type int.
     If we take that literally, we had a (small) problem on 64 bit, since
     sizeof (void*) != sizeof (int).  If we would like to follow POSIX
     more closely than Linux, we'd have to call va_arg on a per cmd basis. */

  va_start (args, cmd);
  arg = va_arg (args, intptr_t);
  va_end (args);

  switch (cmd)
    {
    case F_DUPFD:
    case F_DUPFD_CLOEXEC:
      if (arg >= 0 && arg < OPEN_MAX_MAX)
	{
	  int flags = cmd == F_DUPFD_CLOEXEC ? O_CLOEXEC : 0;
	  res = cygheap->fdtab.dup3 (fd, cygheap_fdnew ((arg) - 1), flags);
	}
      else
	{
	  set_errno (EINVAL);
	  res = -1;
	}
      break;
    case F_GETLK:
    case F_SETLK:
    case F_SETLKW:
      {
	struct flock *fl = (struct flock *) arg;
	fl->l_type &= F_RDLCK | F_WRLCK | F_UNLCK;
	res = cfd->lock (cmd, fl);
      }
      break;
    default:
      res = cfd->fcntl (cmd, arg);
      break;
    }
done:
  syscall_printf ("%R = fcntl(%d, %d, %ly)", res, fd, cmd, arg);
  return res;
}

#ifdef __x86_64__
EXPORT_ALIAS (fcntl64, fcntl)
EXPORT_ALIAS (fcntl64, _fcntl)
#else
extern "C" int
_fcntl (int fd, int cmd, ...)
{
  intptr_t arg = 0;
  va_list args;
  struct __flock32 *src = NULL;
  struct flock dst;

  myfault efault;
  if (efault.faulted (EFAULT))
    return -1;

  va_start (args, cmd);
  arg = va_arg (args, intptr_t);
  va_end (args);
  if (cmd == F_GETLK || cmd == F_SETLK || cmd == F_SETLKW)
    {
      src = (struct __flock32 *) arg;
      dst.l_type = src->l_type;
      dst.l_whence = src->l_whence;
      dst.l_start = src->l_start;
      dst.l_len = src->l_len;
      dst.l_pid = src->l_pid;
      arg = (intptr_t) &dst;
    }
  int res = fcntl64 (fd, cmd, arg);
  if (cmd == F_GETLK)
    {
      src->l_type = dst.l_type;
      src->l_whence = dst.l_whence;
      src->l_start = dst.l_start;
      src->l_len = dst.l_len;
      src->l_pid = (short) dst.l_pid;
    }
  return res;
}
#endif
