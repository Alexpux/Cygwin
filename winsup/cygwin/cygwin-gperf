#!/usr/bin/perl
use strict;
sub read_devices($%);
my $infile = shift;
my $incfile = shift;
open(GPERF, "gperf  -c --key-positions='5-8,1-2,9-10' -r -t -C -E " .
            "-T -L 'ANSI-C' -Hdevhash -N'device::lookup' -Z devstring " .
	    "-7 -G $infile |");
my @lines = <GPERF>;
my $ix = 0;
my $i = 0;
my $n = -1;
my $findclose = 0;
my $add_device = '';
my %fh_static;
my %fh_declare = (
    'cygdrive' => 'dev_cygdrive_storage',
    'fs' => 'dev_fs_storage',
    'proc' => 'dev_proc_storage',
    'registry' => 'dev_registry_storage',
    'process' => 'dev_process_storage',
    'piper' => 'dev_piper_storage',
    'pipew' => 'dev_pipew_storage',
    'tcp' => 'dev_tcp_storage',
    'udp' => 'dev_udp_storage',
    'icmp' => 'dev_icmp_storage',
    'unix' => 'dev_unix_storage',
    'stream' => 'dev_stream_storage',
    'dgram' => 'dev_dgram_storage'
);

foreach (@lines) {
    $i++;
    s/\[(str\[[^\]]*\])\]/[(unsigned) cyg_tolower ($1)]/o and next;
    s/static (.* )wordlist/static NO_COPY $1wordlist/o and do {
	$findclose = 1;
    };
    s/([   ]*)if \(\*str.*$/$1if (strncasematch (str, s, len))/o and next;
    $findclose and /};/o and do {
        $_ .= "\n";
	$_ .=<<'EOF';
const device dev_cygdrive_storage =
  {"/cygdrive", FH_CYGDRIVE, "/cygdrive", 0, 0, 0, 0};

const device dev_fs_storage =
  {"", FH_FS, "", 0, 0, 0, 0};

const device dev_proc_storage =
  {"", FH_PROC, "", 0, 0, 0, 0};

const device dev_registry_storage =
  {"", FH_REGISTRY, "", 0, 0, 0, 0};

const device dev_process_storage =
  {"", FH_PROCESS, "", 0, 0, 0, 0};

const device dev_tcp_storage =
  {"/dev/inet/tcp", FH_TCP, "", 0, 0, 0, 0};

const device dev_udp_storage =
  {"/dev/inet/udp", FH_UCP, "", 0, 0, 0, 0};

const device dev_icmp_storage =
  {"/dev/inet/icmp", FH_ICMP, "", 0, 0, 0, 0};

const device dev_unix_storage =
  {"/dev/inet/unix", FH_UNIX, "", 0, 0, 0, 0};

const device dev_stream_storage =
  {"/dev/inet/stream", FH_STREAM, "", 0, 0, 0, 0};

const device dev_dgram_storage =
  {"/dev/inet/dgram", FH_DGRAM, "", 0, 0, 0, 0};

const device dev_piper_storage =
  {"", FH_PIPER, "", 0, 0, 0, 0};

const device dev_pipew_storage =
  {"", FH_PIPEW, "", 0, 0, 0, 0};

const device dev_fs =
  {"", FH_FS, "", 0, 0, 0, 0};
EOF
        for my $f (sort keys %fh_declare) {
	    $_ .= 'const device dev_' . $f . "_storage = $fh_declare{$f};\n"
	      if $fh_declare{$f} !~ /_storage/;
	}
	$_ .= "\n";
	$_ .= read_devices($incfile, %fh_declare);
	$findclose = 0;
    };
    /^(\s+)(\{".*)/ or next;
    my $indent = $1;
    my $rest = $2;
    for my $f ($rest =~ /\{([^}]+)\}/g) {
	$f eq '""' and do {
	    $ix++;
	    next;
	};
	my ($str, $fh) = (split(/, /, $f))[0..1];
	if ($str !~ m!^"(?:/dev|:bad:)!) {
	    $ix++;
	} else {
	    my $what = lc(($fh =~ /FH_(.+)/o)[0]);
	    my $addon = '';
	    while (defined $fh_static{$what . $addon} &&
		   $fh_static{$what . $addon} ne $f) {
		$addon++;
	    }
	    $what .= $addon;
	    $fh_static{$what} = $f;
	    $fh_declare{$what} = "wordlist[$ix]";
	    $ix++;
	}
    }
}

print @lines;

sub read_devices($%) {
    my $fn = shift;
    my %fh_declare = @_;
    open(F, "$fn") or die "$0: couldn't open $fn - $!\n";
    my (%dev, %fh);
    local $_;
    while (<F>) {
	/^\s*DEV_([A-Z_0-9]+)_MAJOR\s*=\s*(\d+)/ and do {
	    my $dev = lc($1);
	    next unless $fh_declare{$dev};
	    my $a = sprintf "%08d", $2;
	    $dev{$2} = '&' . $fh_declare{$dev} . " /* \L$1 */";
	    next;
	};
	/^\s*FH_([A-Z_0-9]+)\s*=\s*FHDEV\s*\((\d+),\s*(\d+)\)/ and do {
	      my $a = sprintf "%08d.%08d", $2, $3;
	      $fh{$a} = '&' . $fh_declare{lc($1)} . " /* \L$1 */";
	};
    };
    close F;
    my $toprint = '';
    $toprint = "const device *unit_devices[] =\n{";
    for my $f (sort keys %dev) {
	$toprint .= "\n  $dev{$f}," if length($dev{$f});
    }
    chop $toprint;
    $toprint .= "\n};\n\nconst device *uniq_devices[] = \n{";
    for my $f (sort keys %fh) {
	$toprint .= "\n  $fh{$f},";
    }
    chop $toprint;
    $toprint .= "\n};\n";
    return $toprint;
}
